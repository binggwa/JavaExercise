# 1. 서브타입을 가지는 제네릭
***
GenericApp 클래스를 통한 학습
***
# 2. 와일드카드
***
- 제네릭은 가능한 모든 타입에 대한 자리 표시자로서 사용될 수 있는 형식을 제공한다.
  - 이것을 와일드카드 타입이라 부른다.
  - 실제 타입이 들어가야 하는 자리에 "?" 물음표 마크를 사용하여 표시한다.
```java
ex)
public void printCollection(Collection<?> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```
Object로 받으면 어떤 타입이던 안전하다.

어떤 컬렉션 유형이든 전달할 수 있어야 한다.
***
# 3. 바운드 와일드카드
***
- 바운드 와일드카드는 미지의 타입 유형 ? 를 사용할 때, extends 키워드를 통해 그 미지가 어느 정도 범위까지 가능한지 제한하는 역할을 한다.
- 컬렉션에 있는 객체는 upper bound의 subtype이어야 한다.
```java
ex)
public void drawAll(List<? extends Shape> shapes) {
    for (Shape s : shapes) {
        s.draw(this);
    }
}
```
예제의 List에 있는 것이 무엇인지는 정확히 모르지만, 반드시 Shape이어야 한다.
***
### 바운드 와일드카드의 제약
? 가 미지의 타입을 나타내기 때문에 다음과 같은 코드가 불가능해진다.

참조에 추가하거나 할당할 수 없다.
```java
public void drawAll(List<? extends Shape> shapes) {
    for (Shape s : shapes) {
        s.draw(this);
    }
    shapes.add(new Rectangle()); //error
}
```
만약 원의 목록이었다면 어떻게 새로운 직사각형을 전달할 것인가? 하는 제약이 생긴다.
***
# 4. super, extends를 사용한 바운드 제네릭 이해
***
- ? 은 알려지지 않은 타입이므로 add를 사용할 수 없다.
- 그 이유는 구체적으로 부모클래스의 어떤 서브클래스가 들어갈지 알 수 없기 때문이다.
***
- "<? extends T>" 를 사용할 때 add를 사용할 수 없는 문제는 상속과 연관지어서 인식하면 이해하기 쉽다.
- "<? extends T>" 의 선언은 와일드카드가 T나 T의 일부 서브클래스와 매칭된다는 뜻이지만, 어떤 것인지 알 수 없다.
- 반대로, "<? super T>" 의 선언은 와일드카드가 T의 부모클래스와 매칭되는데, 어떤 것인지는 알 수 없어도 모든 부모에는
모두 T가 있기 때문에 super를 사용하면, 제네릭 컬렉션에 add를 사용할 수 있다.
***
- ? extends T 를 사용하면, 참조가 가능하다.
- 하지만 정확한 타입을 모르기 때문에 null을 제외하고는 참조에 추가하거나 할당할 수 없다.
- ? super T 를 사용하면, 슈퍼클래스 참조가 항상 서브클래스를 참조하므로 추가나 할당이 가능해진다.
- 하지만 정확한 타입을 모르기 때문에 참조가 불가능하다.
